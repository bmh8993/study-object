객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다.<br>
1. 객체 지향의 핵심은 책임이다.
2. 책임을 할당하는 작업이 응집도와 결합도 같은 설계 품질과 연관되어 있다.<br>

객체를 단순 제이터의 집합으로 바라보게 된다면 내부 구현을 퍼블릭 인터페이스에 노출 시키게 되므로 설계가 변경에 취약해진다.<br>
이런 문제를 피하기 위해서 객체의 책임에 초점을 맞춘다.
- 객체의 책임을 드러내는 인터페이스 뒤로 책임을 수행하는 데 필요한 상태를 캡슐화 함으로써 구현 변경에 대한 파장이 퍼져나가는 것을 방지한다. 따라서 책임에 초점을 맞추면 상대적으로 안정적인 설계를 얻을수 있다.

## 설계 트레이트오프
좋은 설계의 특징을 판단하는 척도를 캡슐화, 응집도, 결합도로 놓고 이 기준으로 판단해보자.

###캡슐화
변경될 가능성이 높은 부분을 구현, 안정적인 부분을 인터페이스. 외부에서는 인터페이스만 참조하도록 구현해야 좋은 캡슐화.
객체지향에서 가장 중요한 원리는 캡슐화이다.<br>
불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제할수 있기 때문에. -> 변경 가능성이 높은 부분을 객체 내부로 숨기자.

###응집도
모듈 내부에 포함된 오소들이 얼마나 연관되어 있는지를 나타냄. -> 객체에 얼마나 관련 높은 책임들을 할당했는가?

###결합도
의존성을 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지 나태니는 척도.<br>
객체지향 관점에서는 협력에 필요한 적절한 수준의 관계만을 유지하는지 나타내는 말이다.

높은 응집도와 낮은 결합도 -> 👍

## 예메 시스템의 문제점
- 캡슐화 위반
  - get/set method, 함수 이름에서 변수를 노골적으로 들어냄.
  - 겍채가 수행할 책임이 아닌 내부에 저장할 데이터에 초점을 맞춘것이 원인.
- 높은 결합도
- 낮은 응집도
  - reservationAgency처럼 서로 다른 코드들을 하나의 모듈 안에 뭉쳐놓았기 때문에 변경과 아무 상관이 없는 코드들이 모두 영향을 받는다.
  - 책임의 사이즈가 작기 때문에 엉뚱한 곳에 코드를 수정할 경우도 생김
  - 단일 책임의 원칙


## 여전히 부족하다.
두 번째 설계가 확실히 향상된 것은 맞지만 데이터 중심의 설계방식이다. 

### 캡슐화 위반
객체들은 자기 자신의 데이터를 스스로 처리한다. ex) discountCondition
히지만 메소드의 파라미터를 통해 객체 내부의 캡슐화를 저해한다.<br>
왜? 만약에 필드 수정 시 메서드의 파라미터를 수정하고, 해당 메서드를 사용하는 모든 코드를 수정해야한다. (파급효과)<br>
무비에서는 각 할인정책 메소드를 통해 내부 구현을 노출시키고 있다.

### 높은 결합도
movie와 discountCondition의 결합도가 높다. 예를들어 할인 조건이 PEROID에서 다른곳으로 변경됐다면 movie도 수정해야 한다.<br>
discountCondition의 여부를 판단하기 위해서 파라미터가 변경된다면 결과적으로 이 메소드에 의존하는 screening의 변경도 초래한다.

## 데이터 중심 설계의 문제점
1. 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요되었다.
2. 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.
